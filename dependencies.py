import firebase_admin
from firebase_admin import credentials, firestore
import streamlit as st
from datetime import datetime
import re
from fuzzywuzzy import fuzz
import pytz
import os
from dotenv import load_dotenv
import smtplib
import ssl
from email.message import EmailMessage
import subprocess

current_directory = os.path.dirname(__file__)
env_file_path = os.path.join(current_directory, 'cred.env')

load_dotenv(env_file_path)

# Check if Firebase app is already initialized
if not firebase_admin._apps:
    cred = credentials.Certificate("service_account.json")
    firebase_admin.initialize_app(cred)

db = firestore.client()

class Email:
    def __init__(self):
        self.sender = os.getenv('SENDER')
        self.password = os.getenv('PASSWORD')

    def send_email(self, html_content,receiver,subject):
        context = ssl.create_default_context()
        em = EmailMessage()
        em['From'] = self.sender
        em['To'] = receiver
        em['Subject'] = subject
        em.set_content(html_content, subtype = 'html')

        with smtplib.SMTP_SSL('smtp.gmail.com', 465, context=context) as smtp:
            smtp.login(self.sender, self.password)
            smtp.sendmail(self.sender, receiver, em.as_string())


# Firestore collection
collection = db.collection('users')
profile_collection = db.collection('job_seeker_profile')
recruiter_collection = db.collection('recruiter_profile')
job_collection = db.collection('jobs')
application_collection = db.collection('application')

def insert_user(email, username, phone, password, role):
    # Generate a new document reference (with an autogenerated ID)
    doc_ref = collection.document()
    user_id = doc_ref.id  # Get the autogenerated document ID

    user_data = {
        'user_id': user_id,
        'email': email,
        'username': username,
        'phone': phone,
        'password': password,
        'role': role,
        'created_at': datetime.now()
    }
    # Set the document with the generated ID
    doc_ref.set(user_data)
    return user_id  # Return the user_id

def insert_job_seeker_profile(user_id, email, username, phone):
    profile_data = {
        'user_id': user_id,
        'full_name': username,
        'phone': phone,
        'email': email,
        'current_job_title': '',
        'current_employer': '',
        'years_of_experience': '',
        'skills': [],
        'professional_summary': '',
        'linkedin_profile': '',
        'personal_website': '',
        'education': [
            {
                'education_level': '',
                'major': '',
                'institution': '',
                'graduation_year': ''
            }
        ],
        'preferences': {
            'desired_job_title': '',
            'preferred_industries': [],
            'salary_expectations': 0,
            'work_type_preference': []
        }
    }
    profile_collection.document(user_id).set(profile_data)
    # Train the model and evaluate
    subprocess.call(['python', 'evaluation.py'])

def insert_recruiter_profile(user_id, email, username, phone):
    recruiter_data = {
        'user_id': user_id,
        'full_name': username,
        'phone': phone,
        'email': email,
        'company_name': '',
        'company_website': '',
        'office_location': '',
        'company_contact': '',
        'company_email': ''
    }
    recruiter_collection.document(user_id).set(recruiter_data)

def insert_job(user_id, title, company, location, salary=None, job_type='', description='', requirements='', posted_date='', company_website='', company_contact='', benefits=None, job_category='', visibility=False):
    doc_ref = job_collection.document()
    job_id = doc_ref.id  # Get the autogenerated document ID
    job_data = {
        'job_id': job_id,
        'user_id': user_id,
        'title': title.lower(),
        'company': company,
        'location': location,
        'salary': salary,
        'job_type': job_type,
        'description': description,
        'requirements': requirements,
        'posted_date': posted_date,
        'company_website': company_website,
        'company_contact': company_contact,
        'benefits': benefits if benefits else [],
        'job_category': job_category,
        'visibility': visibility
    }
    doc_ref.set(job_data)
    # Train the model and evaluate
    subprocess.call(['python', 'evaluation.py'])
    return job_id

def insert_application(job_seeker_id, recruiter_id, job_id):
    # Check if the application already exists
    query = application_collection.where('job_seeker_id', '==', job_seeker_id)\
                                  .where('recruiter_id', '==', recruiter_id)\
                                  .where('job_id', '==', job_id)\
                                  .limit(1)
    existing_applications = query.stream()

    # If any existing application is found, return an appropriate message
    if any(existing_applications):
        return "Application already exists."

    # If no existing application, insert a new one
    doc_ref = application_collection.document()
    application_id = doc_ref.id
    application_data = {
        'application_id': application_id,
        'job_seeker_id': job_seeker_id,
        'recruiter_id': recruiter_id,
        'job_id': job_id,
        'status': 'Pending for review',
        'created_at': datetime.now()
    }
    doc_ref.set(application_data)
    job = fetch_job_by_id(job_id)
    recruiter = fetch_recruiter_profile_by_id(recruiter_id)
    recruiter_email = recruiter.get('email')

    subject = "Someone Just Applied To Your Job Posted!"

    html_content = f""""
        <html>
            <body>
                <p>Hi {recruiter.get('full_name')}, someone just applied to your job posted: {job.get('title').title()}</p>
                <p>For more information, please check out your home page :)</p>
            </body>
        </html>
    """
    email_client = Email()
    email_client.send_email(html_content,recruiter_email,subject)
    # Train the model and evaluate
    subprocess.call(['python', 'evaluation.py'])
    return application_id


def fetch_users():
    users = collection.stream()
    user_list = [user.to_dict() for user in users]
    return user_list

def fetch_job_seekers():
    job_seekers = profile_collection.stream()
    job_seeker_list = [job_seeker.to_dict() for job_seeker in job_seekers]
    return job_seeker_list

def fetch_recruiters():
    recruiters = recruiter_collection.stream()
    recruiter_list = [recruiter.to_dict() for recruiter in recruiters]
    return recruiter_list

def fetch_jobs():
    jobs = job_collection.stream()
    job_list = [job.to_dict() for job in jobs]
    return job_list

def fetch_applications():
    applications = application_collection.stream()
    application_list = [application.to_dict() for application in applications]
    return application_list

def fetch_job_application_counts(job_ids):
    """
    Fetches the number of applications for the specified list of job IDs.
    
    Parameters:
    - job_ids (list): A list of job IDs for which to fetch the application counts.

    Returns:
    - dict: A dictionary with job IDs as keys and the number of applications as values.
    """
    job_application_counts = {job_id: 0 for job_id in job_ids}

    # Fetch all job applications
    applications = application_collection.stream()

    # Count applications per job
    for application in applications:
        application_data = application.to_dict()
        job_id = application_data.get('job_id')

        if job_id in job_application_counts:
            job_application_counts[job_id] += 1

    return job_application_counts

def fetch_user(user_id):
    user_ids = collection.where('user_id', "==", user_id).stream()
    for user in user_ids:
        return user.to_dict()
    return False

def update_user_profile(user_id, user_data):
    users = collection.where('user_id', "==", user_id).stream()
    for user in users:
        user.reference.update(user_data)
        return True
    return False

def fetch_user_by_email(email):
    user_ids = collection.where('email', "==", email).stream()
    for user in user_ids:
        return user.to_dict()
    return False


def fetch_job_seeker_profile(user_id):
    profiles = profile_collection.where('user_id', '==', user_id).stream()
    for profile in profiles:
        return profile.to_dict()
    return None

def fetch_job_seeker_profile_by_id(user_id):
    profiles = profile_collection.where('user_id', '==', user_id).stream()
    for profile in profiles:
        return profile.to_dict()
    return None

def fetch_recruiter_profile(user_id):
    recruiters = recruiter_collection.where('user_id', '==', user_id).stream()
    for recruiter in recruiters:
        return recruiter.to_dict()
    return None

def fetch_recruiter_profile_by_id(user_id):
    recruiters = recruiter_collection.where('user_id', '==', user_id).stream()
    for recruiter in recruiters:
        return recruiter.to_dict()
    return None

def fetch_job_by_id(job_id):
    jobs = job_collection.where('job_id', '==', job_id).stream()
    for job in jobs:
        return job.to_dict()
    return None

def fetch_application_by_id(application_id):
    applications = application_collection.where('application_id', '==', application_id).stream()
    for application in applications:
        return application.to_dict()
    return None

def fetch_specific_jobs(user_id):
    jobs = job_collection.where('user_id', '==', user_id).stream()
    job_list = [job.to_dict() for job in jobs]
    return job_list

def fetch_application(job_id, recruiter_id):
    # Query the collection to get applications for the given job_id and recruiter_id
    applications = application_collection.where('job_id', '==', job_id).where('recruiter_id', '==', recruiter_id).stream()
    
    # Convert the applications to a list of dictionaries
    application_list = []
    for application in applications:
        application_data = application.to_dict()
        application_list.append(application_data)
    
    return application_list


def fetch_application_by_job_seeker(job_seeker_id):
    applications = application_collection.where('job_seeker_id', '==', job_seeker_id).stream()

    application_list = []
    for application in applications:
        application_data = application.to_dict()
        application_list.append(application_data)

    return application_list

def update_job(job_id, title, company, location, salary, job_type, description, requirements, company_website, company_contact, benefits, job_category, visibility):
    job_ref = db.collection('jobs').document(job_id)
    
    # Update the job document
    job_ref.update({
        'title': title.lower(),
        'company': company,
        'location': location,
        'salary': salary,
        'job_type': job_type,
        'description': description,
        'requirements': requirements,
        'company_website': company_website,
        'company_contact': company_contact,
        'benefits': benefits,
        'job_category': job_category,
        'visibility': visibility
    })
    # Train the model and evaluate
    subprocess.call(['python', 'evaluation.py'])



def delete_job(job_id):
    job_ref = db.collection('jobs').document(job_id)
    
    try:
        # Delete the job document
        job_ref.delete()
        
        # Delete all applications associated with this job
        applications = application_collection.where('job_id', '==', job_id).stream()
        for application in applications:
            application.reference.delete()
        # Train the model and evaluate
        subprocess.call(['python', 'evaluation.py'])
        return True
    except Exception as e:
        return False


def update_job_seeker_profile(user_id, profile_data):
    profiles = profile_collection.where('user_id', '==', user_id).stream()
    for profile in profiles:
        profile.reference.update(profile_data)
        # Train the model and evaluate
        subprocess.call(['python', 'evaluation.py'])
        return True
    return False

def update_recruiter_profile(user_id, recruiter_data):
    recruiters = recruiter_collection.where('user_id', '==', user_id).stream()
    for recruiter in recruiters:
        recruiter.reference.update(recruiter_data)
        return True
    return False

def update_application_status(application_id):
    doc_ref = application_collection.document(application_id)
    doc_ref.update({'status': 'Reviewed'})
    application = fetch_application_by_id(application_id)
    job = fetch_job_by_id(application.get('job_id'))
    job_seeker = fetch_job_seeker_profile_by_id(application.get('job_seeker_id'))
    job_seeker_email = job_seeker.get('email')
    recruiter = fetch_recruiter_profile_by_id(application.get('recruiter_id'))

    subject = "Your Job Application Has Been Reviewed!"

    html_content = f"""
        <html>
            <body>
                <p>Hi {job_seeker.get('full_name')}, a recruiter from {recruiter.get('company_name')} has reviewed your application for: {job.get('title').title()}</p>
                <p>For more information, please check out your application histories page.</p>
                <p>Good luck and be prepared for any interview session :)</p>
            </body>
        </html>
    """
    email_client = Email()
    email_client.send_email(html_content,job_seeker_email,subject)


def get_usernames():
    users = collection.stream()
    usernames = [user.to_dict().get('username') for user in users if 'username' in user.to_dict()]
    return usernames

def get_user_emails():
    users = collection.stream()
    emails = [user.to_dict().get('email') for user in users if 'email' in user.to_dict()]
    return emails
    
def get_user_phones():
    users = collection.stream()
    phones = [user.to_dict().get('phone') for user in users if 'phone' in user.to_dict()]
    return phones

def get_company_contacts():
    recruiters = recruiter_collection.stream()
    company_contacts = [recruiter.to_dict().get('company_contact') for recruiter in recruiters if 'company_contact' in recruiter.to_dict()]
    return company_contacts

def validate_email(email):
    pattern = "^[a-zA-Z0-9-_]+@[a-zA-Z0-9]+\.[a-z]{1,3}$" 
    return re.match(pattern, email) is not None

def validate_username(username):
    pattern = "^[a-zA-Z0-9 ]*$"
    return re.match(pattern, username) is not None

def validate_phone(phone):
    pattern = r"^\+\d{1,3}\d{9,15}$"
    return re.match(pattern, phone) is not None

def sign_up():
    with st.form(key='signup', clear_on_submit=True):
        st.subheader(':green[Sign Up As Job Seeker]')
        username = st.text_input(':blue[Name]', placeholder='Enter Your Full Name')
        email = st.text_input(':blue[Email]', placeholder='Enter Your Email')
        phone = st.text_input(':blue[Phone Number]', placeholder='Enter Your Phone Number (e.g., +123456789012)')
        password1 = st.text_input(':blue[Password]', placeholder='Enter Your Password', type='password')
        password2 = st.text_input(':blue[Confirm Password]', placeholder='Confirm Your Password', type='password')
        submit_button = st.form_submit_button('Sign Up')

        if submit_button:
            # Validate username
            if not username:
                st.warning('Empty Name')
                return
            
            # Validate email
            if not validate_email(email):
                st.warning('Invalid Email')
                return

            # Check if email already exists
            if email in get_user_emails():
                st.warning('Email Already Exists')
                return

            # Validate phone number
            if not validate_phone(phone):
                st.warning('Invalid Phone Number (Format: +CountryCodePhoneNumber)')
                return
            
            # Check if phone number already exists
            if phone in get_user_phones():
                st.warning('Phone Number Already Exists')
                return

            # Validate username
            if not validate_username(username):
                st.warning('Invalid Name')
                return

            # Validate password length
            if len(password1) < 6:
                st.warning('Password is Too Short (Minimum 6 characters)')
                return

            # Confirm password match
            if password1 != password2:
                st.warning('Passwords Do Not Match')
                return

            # Add user to Firestore
            user_id = insert_user(email, username, phone, password1, 1)
            st.success('Account created successfully!')
            st.balloons()
            insert_job_seeker_profile(user_id, email, username, phone)
            

def recruiter_sign_up():
    with st.form(key='signup', clear_on_submit=True):
        st.subheader(':green[Sign Up As Recruiter]')
        username = st.text_input(':blue[Name]', placeholder='Enter Your Full Name')
        email = st.text_input(':blue[Email]', placeholder='Enter Your Email')
        phone = st.text_input(':blue[Phone Number]', placeholder='Enter Your Phone Number (e.g., +123456789012)')
        password1 = st.text_input(':blue[Password]', placeholder='Enter Your Password', type='password')
        password2 = st.text_input(':blue[Confirm Password]', placeholder='Confirm Your Password', type='password')
        submit_button = st.form_submit_button('Sign Up')

        if submit_button:
            # Validate username
            if not username:
                st.warning('Empty Name')
                return
            
            # Validate email
            if not validate_email(email):
                st.warning('Invalid Email')
                return

            # Check if email already exists
            if email in get_user_emails():
                st.warning('Email Already Exists')
                return

            # Validate phone number
            if not validate_phone(phone):
                st.warning('Invalid Phone Number (Format: +CountryCodePhoneNumber)')
                return
            
            # Check if phone number already exists
            if phone in get_user_phones():
                st.warning('Phone Number Already Exists')
                return

            # Validate username
            if not validate_username(username):
                st.warning('Invalid Name')
                return

            # Validate password length
            if len(password1) < 6:
                st.warning('Password is Too Short (Minimum 6 characters)')
                return

            # Confirm password match
            if password1 != password2:
                st.warning('Passwords Do Not Match')
                return

            # Add user to Firestore
            user_id = insert_user(email, username, phone, password1, 2)
            insert_recruiter_profile(user_id, email, username, phone)
            st.success('Account created successfully!')
            st.balloons()

def search_jobs(search_query):
    jobs = job_collection.stream()
    search_query_lower = search_query.lower()
    
    job_list = []
    for job in jobs:
        job_data = job.to_dict()
        title = job_data.get('title', '').lower()
        description = job_data.get('description', '').lower()
        requirements = job_data.get('requirements', '').lower()
        visibility = job_data.get('visibility', False)
        
        # Apply fuzzy matching only if the job is visible
        if visibility:
            title_match = fuzz.partial_ratio(search_query_lower, title)
            description_match = fuzz.partial_ratio(search_query_lower, description)
            requirements_match = fuzz.partial_ratio(search_query_lower, requirements)
            
            # Consider job if any of the fields have a sufficient match
            if max(title_match, description_match, requirements_match) > 70:  # Adjust the threshold as needed
                job_list.append(job_data)
    
    return job_list

def convert_to_malaysia_time(utc_datetime_str):
    if utc_datetime_str == 'N/A':
        return utc_datetime_str
    utc_datetime = datetime.fromisoformat(str(utc_datetime_str))
    malaysia_tz = pytz.timezone('Asia/Kuala_Lumpur')
    malaysia_datetime = utc_datetime.astimezone(malaysia_tz)
    return malaysia_datetime.strftime('%d/%m/%Y')
